# MAGport Snakefile
# Orchestrates modular MAG characterization

import os
from pathlib import Path

configfile: "config/config.yaml"

# CLI-provided config keys (with defaults):
INPUT_DIR = Path(config.get("input_dir", "input")).resolve()
OUTPUT_DIR = Path(config.get("output_dir", "results")).resolve()
EXT = config.get("file_extension", ".fasta")
THREADS = int(config.get("threads", 8))
MODULES = set((config.get("modules", "stats,quality,park,gunc,rrna,trna,orfs,gtdb,rrna16S,mimag").split(',')))
USE_CHECKM = config.get("use_checkm", "checkm2")

# Database download paths (for magport download command)
DB_BASE = Path(config.get("db_base", OUTPUT_DIR / "resources"))
config.setdefault("checkm2_download_path", str(DB_BASE / "checkm2_db"))
config.setdefault("gunc_download_path", str(DB_BASE / "gunc_db"))
config.setdefault("gtdb_download_path", str(DB_BASE / "gtdbtk"))
config.setdefault("ncbi16s_download_path", str(DB_BASE / "ncbi_16s"))

# I/O structure
RESULTS = OUTPUT_DIR / "results"
LOGS = OUTPUT_DIR / "results" / "logs"
SUMMARY_TSV = OUTPUT_DIR / "MAGport_summary.tsv"
REPORT_HTML = OUTPUT_DIR / "MAGport_report.html"

# Get database paths from environment variables or config
def get_db_path(config_key: str, env_var: str, default: str) -> Path:
    return Path(
        os.environ.get(env_var) or 
        config.get(config_key) or 
        str(OUTPUT_DIR / default)
    ).resolve()

# Databases with env var fallbacks
CHECKM2_DB = get_db_path("checkm2_db_dir", "CHECKM2_DB_PATH", "resources/checkm2_db")
CHECKM1_DB = get_db_path("checkm1_db_dir", "CHECKM1_DB_PATH", "resources/checkm1_db")
GUNC_DB = get_db_path("gunc_db_dir", "GUNC_DB_PATH", "resources/gunc_db")
NCBI16S_DIR = get_db_path("ncbi16s_dir", "NCBI16S_DB_PATH", "resources/ncbi_16s")
GTDBTK_DB = get_db_path("gtdbtk_db_dir", "GTDBTK_DB_PATH", "resources/gtdbtk")

# Verify databases before workflow starts
# Import database verification function
verify_all_databases = None
with open("workflow/rules/databases.smk", 'rt') as f:
    exec(compile(f.read(), "workflow/rules/databases.smk", 'exec'))

onstart:
    try:
        if verify_all_databases:
            verify_all_databases()
    except ValueError as e:
        print(f"[MAGport] Error: {e}")
        sys.exit(1)

# Discover MAGs
MAGS = sorted([str(p) for p in INPUT_DIR.glob(f"**/*{EXT}")])
SAMPLES = {Path(p).stem: str(Path(p).resolve()) for p in MAGS}
SAMPLE_LIST = sorted(SAMPLES.keys())

if not MAGS:
    print(f"[MAGport] No MAGs found in {INPUT_DIR} with extension {EXT}. The workflow may do nothing.")

# Targets
def per_mag_outputs(module: str):
    outs = []
    if module == "stats":
        outs = [RESULTS/"seqkit"/(s+".seqkit.tsv") for s in SAMPLE_LIST]
    elif module == "quality":
        suf = ".checkm2.tsv" if USE_CHECKM == "checkm2" else ".checkm1.tsv"
        outs = [RESULTS/"quality"/(s+suf) for s in SAMPLE_LIST]
    elif module == "park":
        outs = [RESULTS/"park"/(s+".park.tsv") for s in SAMPLE_LIST]
    elif module == "gunc":
        outs = [RESULTS/"gunc"/(s+".gunc.tsv") for s in SAMPLE_LIST]
    elif module == "rrna":
        outs = [RESULTS/"rrna"/(s+".rrna.tsv") for s in SAMPLE_LIST]
    elif module == "trna":
        outs = [RESULTS/"trna"/(s+".trna.tsv") for s in SAMPLE_LIST]
    elif module == "orfs":
        outs = [RESULTS/"orfs"/(s+".orfs.tsv") for s in SAMPLE_LIST]
    elif module == "gtdb":
        outs = [RESULTS/"gtdbtk"/(s+".gtdb.tsv") for s in SAMPLE_LIST]
    elif module == "rrna16S":
        outs = [RESULTS/"16S"/(s+".16S.tsv") for s in SAMPLE_LIST]
    elif module == "mimag":
        outs = [RESULTS/"mimag"/(s+".mimag.tsv") for s in SAMPLE_LIST]
    return outs

SELECTED = [m for m in [
    "stats","quality","park","gunc","rrna","trna","orfs","gtdb","rrna16S","mimag"
] if m in MODULES]

# Build target outputs based on selected modules
def get_all_targets():
    targets = []
    for m in SELECTED:
        targets.extend(str(p) for p in per_mag_outputs(m))
    targets.extend([str(SUMMARY_TSV), str(REPORT_HTML)])
    return targets

rule all:
    input:
        get_all_targets()# Utility: determine domain for barrnap (requires GTDB-Tk output)
# This is simplified and handled in the python script.

# Get workflow directory (directory containing the Snakefile)
workflow.workflow_dir = os.path.dirname(workflow.snakefile)

# Envs (paths relative to workflow directory)
ENV = {k: os.path.join(workflow.workflow_dir, "envs", f"{k}.yaml") for k in [
    "seqkit",
    "checkm2",
    "checkm1",
    "gunc",
    "barrnap",
    "trnascan",
    "prodigal",
    "gtdbtk",
    "diamond",
    "python"
]}

# Include rules
include: "rules/databases.smk"
include: "rules/stats.smk"
include: "rules/quality.smk"
include: "rules/park.smk"
include: "rules/gunc.smk"
include: "rules/rrna.smk"
include: "rules/trna.smk"
include: "rules/orfs.smk"
include: "rules/gtdb.smk"
include: "rules/rrna16s.smk"
include: "rules/mimag.smk"
include: "rules/collect.smk"
include: "rules/report.smk"
